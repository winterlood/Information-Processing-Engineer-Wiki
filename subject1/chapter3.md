# 1과목 - 소프트웨어 설계 Chapter 3. sw 아키텍쳐
## Section 20. 소프트웨어 아키텍쳐
### sw 아키텍쳐의 설계

- sw를 구성하는 요소들간의 관계를 표현하는 시스템의 구조 or 구조체

- 원칙과 지침

- 비기능요구사항으로 나타난 제약을 반영

- 기능 요구사항을 구현하는 방법을 찾는 해결과정

- 분할방법, 분할 모듈 할당기능, 모듈간 인터페이스 결정

- 기본원리
  ```
  모듈화
  추상화
  단계적 분해
  정보은닉
  ```

### 모듈화

- 재사용 수정 유지관리가 용이하게 모듈단위로 기능을 쪼갬
  - 자주 사용하는 계산식
  - 사용자 인증
  - 통합 비용, 개발 비용 고려

### 추상화

- 문제를 전체적이고 포괄적으로 개념을 설계

- 차례대로 세분화하여 구체화 시키는것

- 완전한 시스템을 만들기 전에 비슷하게 대충 만들고, 여러가지 요인들을 하나하나 붙여나가는것

- 실제상황에 대처가능

- 시스템의 구조 및 구성을 대략적으로 파악 가능

- 유형
```
1. 과정 추상화 : 자세한 수행과정 정의x, 전반적인 흐름만 파악

2. 데이터 추상화 : 데이터의 세부 속성, 용도정의는 하지 않고, 데이터 구조를 대표할 수 있는 표현으로 대체

3. 제어 추상화 : 이벤트 발생의 정확한 절차, 방법정의 x 대표할 수 있는 표현으로 대체
```

### 단계적 분해

하향식 설계 전략
문제를 상위의 중요개념부터 하위 개념으로 구체화 시키는것

- 추상화의 반복으로 세분화
  

### 정보 은닉

기법이다. 과정이 아니다
다른 모듈이 접근하지 못하거나 변경하지 못하도록 하는 기법

### 소프트웨어 아키텍쳐 품질 속성

- 시스템 측면
  ```
  성능
  보안
  가용성
  기능성
  사용성
  변경 용이성
  확장성
  기타 속성 ( 테스트 용이성, 배치성, 안정성 )
  ```

- 비즈니스 측면
  ```
  시장 적시성
  비용과 혜택
  예상 시스템 수명
  기타 속성 ( 목표시장, 공개일정, 기존시스템과의 통합 )
  ```

- 아키텍쳐 측면
  ```
  개념적 무결성
  정확성
  완결성
  구축 가능성
  기타 속성 ( 변경성, 시험성, 적응성, 일치성, 대체성 )
  ```

### 아키텍쳐 설계 과정

1. 설계 목표를 설정
    > 시스템의 개발 방향을 정하는 것  
    > 비즈니스 목표, 우선순위 등의 **요구사항**을 분석   
    > 전체 시스템의 설계 목표를 설정함

2. 시스템의 타입 결정
    > 시스템, 서브시스템의 타입 결정  
    > 설계 목표와 함께 고려하여 아키텍쳐 패턴 선택

3. 아키텍쳐 패턴 적용
    > 기존꺼 많이 참고해서 함

4. 서브시스템 구체화
    > 서브 시스템 기능  
    > 서브 시스템간 상호작용 정의  
    > 서브 시스템간 인터페이스 정의

5. 검토

### 기출문제

1. 2
2. 2
3. 1 ( 틀림 2 )
4. 4
5. 3 ( 틀림 4 ) 

## Section 21. 아키텍쳐 패턴
### 아키텍쳐 패턴의 개요

- 전형적인 방식
- 마치 족보
- 기본적 윤곽제시
- 서브시스템의 역할이 정의되어있음
- 인터페이스도 포함
- 아키텍쳐 스타일, 표준 아키텍쳐라고도 부름

- 장점
  - 시행착오 x
  - 개발시간 단축
  - 소프트웨어 품질 향상
  - 검증된 구조 안정적 개발
  - 의사소통 쉬움
  - 구조 이해 쉬움
  - 특성을 개발전에 예측가능

### 레이어 패턴

시스템을 계층별로 구분하여 구성하는 고전적인 방법

- 서브시스팀끼리 계층을 이룸
- 마주보는 층 사이에서만 상호작용이 일어난다
- 클라이언트는 가장 낮은 층
- 상위 계층은 하위계층에 정보를 제공함
- osi 참조 모델이 있음
- 특정 계층만 교체가능

### 클라이언트-서버 패턴

하나의 서버 - 다수의 클라이언트 
> 컴포넌트 라고 부르기도 함  
> 컴포넌트란 독립적인 업무를 수행하는 모듈

- 사용자는 클라이언트랑 의사소통함
- 클라이언트와 서버는 요청, 응답을 받기위해 동기화하는경우를 제외하고 모두 독립적임
- 서버는 항상 listen을 유지함

### 파이프-필터 패턴

유튜브임
데이터 스트림의 절차를 필터로 캡슐화하여 파이프를 통해 전송
- 필터 컴포넌트는 재사용이 좋음
- 추가가 쉬움 확장 용이
- 다양한 재배치 가능
- 버퍼링, 동기화 등등에 사용한다
- Unix의 쉘이다

### MVC 패턴

- 서로 영향을 안준다
- 여러개의 뷰를 만들어 하나의 모델에 연결가능
- 채팅같은거 만들기 쉽다

### 기타

1. 마스터 & 슬레이브 
    - 마치 리액트
    - 병렬작업이 쉽다
    - 장애허용이 좋다
2. 브로커
    - 원하는걸 말하면 브로커가 가져다 준다
3. 피투피
4. 이벤트-버스
5. 블랙보드
    - 해결책이 명확하지 않은문제
    - 블랙보드가 공유 뇌가 된다
6. 인터프리터

### 기출문제

1. 4
2. 3
3. 2
4. 3
5. 4
6. 4

## Section 22. 객체지향
### 개요

현실 세계의 개체 (Entity)를 기계의 부품처럼 
하나의 객체로 만드는것,

마치 부품을 조립하듯이 제품을 만드는것  

소프트웨어를 개발할때도 객체들을 조립해서 작성함

- 구조적 기법의 문제점으로 인한 해결책
  - 프로시저에 근간을 두고 하나의 커다란 작업을 여러개의 작은작업으로 ... 분할정복...

- 재사용 확장 용이

- 소프트웨어 개발이 빠르고 유지보수가 쉬움

- 복잡한 구조를 단계 - 계층적으로 표현

- 멀티미디어 데이터 및 병렬처리 지원

- 현실세계를 모형화 하므로 사용자와 개발자가 쉽게 이해가능

- 객체 클래스 캡슐화 상속 다형성 존재

### 객체

- 데이터, 데이터를 처리하는 함수를 묶어놓은 (캡슐화)

- 하나의 소프트웨어 모듈

데이터 : 객체가 가지고 있는 정보 속성, 상태, 변수, 상수, 자료구조

함수 : 객체가 수행하는 기능이다. 객체가 갖는 데이터를 처리하는 알고리즘 method, service, operation이라고 불림

- 객체의 특성
  - 1. 객체는 독립적으로 식별 가능한 이름을 갖는다
  - 2. 객체가 가질 수 있는 조건을 상태(state)라고 한다.
        - 일반적으로 이 상태는 시간이 지남에 따라 변함
  - 3. 객체는 객체와 상호연관성에 의해 관계를 형성함
  - 4. 객체가 반응할 수 있는 메세지의 집합을 행위라고 하며 객체는 행위의 특징을 나타낼 수 있음
  - 5. 객체는 일정한 기억장소를 가지고 있다.


- 객체의 메소드는 다른 객체로부터 메세지를 받았을때 비로소 기능을 수행한다 (정해진 기능)

### 클래스
객체보다 큰놈이다 빵틀임

공통된 속성과 연산을 갖는 객체의 집합

객체의 일반적인 타입을 의미함

- 클래스는 각각의 객체들이 갖는 속성과 연산을 정의함
- 클래스에 속한 객체를 인스턴스라고 함
- 새로운 객체를 만드는것을 인스턴스화 라고 함
- 동일 클래스에 속한 객체들은 공통된 속성과 행위를 가지면서 속성이 다르면 다른 행위를 할 수도 있음
- 최상위 클래스는 자기보다 상위가 없는 클래스임
- 슈퍼클래스는 특정 클래스의 부모이다

### 캡슐화
데이터 와 데이터를 처리하는 함수를 하나로 묶는것
- 이렇게 된 객체는 정보은닉 되었다고 말함
- 재사용이 용이
- 세부내용 알필요 없으므로 결합도 낮아짐

### 상속
이미 정의된 상위클래스의 모든 속성과 연산을 물려받는것

- 재사용을 높이는 꿀팁이다
- 다중상속 - 말그대로이다

### 다형성

### 기출문제

1. 1
2. 4
3. 2
4. 1
5. 1


## Section 23. 모듈
### 개요

모듈 -> 모듈화를 통해 분리된 기능

서브루틴, 서브시스템, 등등과 같이 사용된다

- 단독 컴파일이 가능하다
- 재사용 가능하다
- 기능적 독립성 : 각 모듈의 기능이 서로 독립된것임을 의미하는것
모듈이 하나만의 기능을 수행하고 다른모듈과의 과도한 상호작을을 배제하면서 이루어진다.
- 독립성이 높은 모듈일 수록, 해당 모듈을 수정해도 파급 x
- 결합도, 응집도에 의해 독립성을 측정함

### 결합도

1. 자료결합도
   -   모듈간 교환하는게 자료만 일때
   ```
    void print(int x) {
        print(x);
    }
    void main (){
        int x = 3;
        print(x);
    }
   ```
2. 스탬프 결합도
   - 모듈간 교환하는게 배열, 레코드등의 자료구조일때 
   두 모듈이 동일한 자료구조를 조회
   자료구조의 변화, 포맷이나 구조의 변화에 영향을 받게된다
   ```
    Struct point {
        int x;
        int y;
    }
    void print(point pts) {
        ...
    }
    void main (){
       print(new point(3,3));
    }
   ```
3. 제어 결합도
   - 어떠한 모듈이 다른 모듈내부의 논리적인 흐름을 제어하기 위해
   제어신호를 이용하여 통신하거나, 제어요솔르 전달하는 결합도

   ```
    void local (int isExec){
        if(isExec){
            doSomething();
        }else{
            doElseSomething();
        }
    }

    void main (){
        local(1);
    } 
   ```
   -  보통 하나의 모듈이 다른 모듈의 상세한 처리절차를 알아, 이를통제하는 경우에 해당된다.
    하위 모듈에서 상위모듈로 제어신호가 이동하여 하위가 상위에게 처리명령을 내리는 권리전도가 발생할 수도 있다.
4. 외부 결합도
   - 특정 모듈에서 선언한 변수를 외부에 다른모듈에서 참조 할 때
   - 참조되는 데이터의 범위를 각 모듈에서 제어 가능
   - 의존?
5. 공통 결합도
   - 공통된 데이터 영역을 사용할 때
   - 보통 싱글턴, 스태틱 객체를 같이 사용할 때
  ```
    static int a = 3;
    void foo (){
        print(a);
    }

    void main (){
        print(a);
    } 
  ```
6. 내용 결합도
   - 하나의 모듈이 다른 모듈의 내부기능 및 내부자료를 직접 참조, 수정할때
   - 하나의 모듈에서 다른 모듈로 제어를 이동시킬때
   ```
    void foo (){
        foo...
    }

    void main (){
        GO TO foo;
    } 
   ```

### 응집도

응집도는 정보은닉 개념을 확장한것  
- 다양한 기준으로 모듈을 만들 수 있으나 응집도가 높을수록 좋다

1. 우연적 응집도
2. 논리적 응집도
   - 유사한 성격을 가지거나 특정 형태로 분류되는 처리요소
3. 시간적 응집도
4. 절차적 응집도
5. 교환적 응집도
6. 순차적 응집도
7. 기능적 응집도

### 기출문제

1. 1
2. 4
3. 1
4. 4
5. 4
6. 3
7. 2

## Section 24. 공통-모듈
### 개요
여러 프로그램에서 공통적으로 사용할 수 있는 모듈
- 계산식, 인증
- 중복 회피를 위함
- 명세기법
  1. 정확성
   - 해당 기능이 왜 필요한지 정확히 알 수 있도록
  2. 명확성
   - 해당 기능을 이해할 때 해석하다가 안헷갈리게
  3. 완전성
   - 하나도 빠트리지말고 다 기술하기
  4. 일관성
   - 공통기능들 사이에 충돌이 없도록
  5. 추적성
   - 어디서 온 정보인지, 어떤 시스템을 사용하는지를 알 수 있도록

### 재사용

- 재사용 규모에 따른 분류
  1. 함수와 객체 : 클래스, 메소드
  2. 컴포넌트 : 인터페이스를 통해 통신
  3. 어플리케이션 : 어플리케이션 자체를 공유 

### 효과적인 모듈설계
- 당연한 이야기만 있다.
> 하나의 입구, 하나의 출구


### 기출문제

1. 3
2. 4
3. 4
4. 3


## Section 25. 코드
### 개요
Code는 마치 007과 같다.

- 주민번호, 학번, 전화번호 
- 식별 : 구분가능
- 분류 : 그룹화 가능
- 배열 : 의미 부여 나열 가능

### 종류

1. 순차 코드
   - 자료의 발생순서, 크기 순서 등등 그냥 순차적으로 1,2....n
  
2. 블록 코드
   - 공통적인 것들을 블록으로 구분, 
   - 블록내에 일련번호를부여
  ```
  1001 ~ 1100 : 서울대
  1101 ~ 1200 : 고려대
  ```
3. 10진 코드
   - 10진분할
   - 1000 : 공학
   - 1100 : 소공

4. 그룹 분류 코드
   - 대, 중, 소 로 그룹으로 분류
   - 대-중-소 : 1-01-100

5. 연상 코드
   - 연상 잘되게 
   - Tv-40

6. 표의 숫자 코드
   - 길이 넓이 부피 등등 물리적 수치를 그대로 코드로
   - 유효 숫자 코드라고도 한다

7. 합성코드
   - 연상코드 + 순차코드
   - KE-711

### 코드 부여체계

이름만으로 개체의 용도와 범위를 알 수 있도록

### 기출문제

1. 4
2. 2
3. 2
4. 3
5. 3
6. 2

## Section 26. 디자인 패턴
### 생성패턴

1. 추상 팩토리
   - 구체적인 클래스에 의존하지 않는다
   - 인터페이스를 통해 서로 연관 의존 하게끔 객체를 그룹핑하여
   - 추상적으로 표현하는것
   - 연관된 서브클래스를 묶어 한번에 교체하는것이 가능하게 한다

2. 빌더 패턴
   - 작게 분리된 인스턴스를 건축하듯이 조립해서 객체를 생성함
  ```
  Member customer = Member.build()
    .name("홍길동")
    .age(30)
    .build();
  ```
  - 뭐 이런것이다.

3. 팩토리 메소드
   - 객체생성을 서브클래스가 공장처럼 찍어낸다
   - 실제 생성은 서브클래스인 팩토리 클래스가 담당한다

4. 프로토타입 패턴
   - 복사하는것이다
   - 그냥 원본객체를 복사해버린다!
   - 비용이 큰 경우 이용한다
  
5. 싱글턴

### 구조 패턴

1. 어댑터
   - 변환기

2. 브릿지
   - 구현부에서 추상층을 분리한다
   - 서로가 독립적으로 확장할 수 있도록 구성한다
   - 동물과 사냥법을 분리한다...

3. 컴포지트
   - 디렉토리 구조를 생각하자
   - 복합객체와 단일객체를 구분없이!

4. 데코레이터

5. 퍼싸드
   - 외부에 하나의 인터페이스 만을 공개

6. 플라이웨이트
   - 초 경량 인스턴스를 공유하는것

7. 프록시
   - 접근이 어려운 애 사이에서 도와주는것

### 행위 패턴

1. 책임 연쇄
   - 책임을 다 못져서 다음 객체로 책임 전가

2. 커맨드

3. 인터프리터 
   - 언어 문법정의
   - SQL 

4. 반복자
   - 동일한 접근인터페이스
   - 객체 사이의 의존성을 줄인다

5. 중재자
   - 유재석씨

6. 메멘토
   - ctrl + z 만들때 쓰인다.
   - 특정 시점에서 객체의 내부상태를 객체화 하는것

7. 옵저서

8. 상태

9. 전략

10. 템플릿메소드

11. 방문자

### 기출문제
1. 1
2. 2
3. 3
4. 3
5. 4
6. 3

## 문제 은행

1. 3
2. 3
3. 2
4. 1
5. 4
6. 1
7. 1
8. 4
9. 1
10. 2
11. 2
12. 4
13. 2
14. 3
  15. 2 / 3
16. 3
17. 1
18. 2
19. 1
20. 2
21. 1
22. 2
23. 2
24. 2
25. 3
  26. 1 / 2
27. 4
28. 1
29. 3
30. 2
31. 4
32. 2
33. 4
34. 2
35. 4
36. 1
37. 2