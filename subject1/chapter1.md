# 1과목 - 소프트웨어 설계 Chapter 1. 요구사항 확인
## Section 1. 소프트웨어 생명 주기
### 소프트웨어 생명주기
소프트웨어의 생명주기는 다음 과정을 단계별로 분류한 것.
- 소프트웨어 개발단계
- 단계별 활동
- 활동의 결과에 대한 산출물
> 수명주기라고도 부른다

위 생명주기를 표현하는 형태를 생명주기 모형이라고 부르며,
소프트웨어 프로세스 모형, 공학 패러다임 이라고 부르기도 한다.

개발자는 문제의 유형, 개발 방법에 따라
적절한 모형을 선택하여 사용한다

일반적으로, 폭포수, 프로토타입, 나선형, 애자일이 존재한다.


### 폭포수 모형

- 이전 단계로 돌아 갈 수 없음
- 단계별로 확실한 매듭이 필요
- 단계별로 검토, 승인 과정을 거침
- n-1 단계가 수행되어야 n 단계 수행가능
  > 선형 순차적 모형이라고도 한다  
  > 이 때문에, 단계가 끝난 후, 다음단계 수행을 위한 확실한 결과물이 있어야 한다고 함
- 가장 넓고 오래된 전통 모형
  > 고전적 모형이라고도 함
- 제품의 일부가 될 매뉴얼을 작성해야 함
  > 매뉴얼이란 운영과 사용에 대해 기술해놓은 문서
- 병렬수행 불가능

**순서**
```
타당성검토 -> 계획 -> 요구분석 -> 설계 -> 구현 -> 시험 -> 유지보수
```

### 프로토타입 모형

- 요구사항이 뭔지 모르겠을 때, 한번 만들어보는것이다
- 견본(시제품)을 만들어 최종결과물을 예측함
> 사용자와 시스템 사이의 인터페이스에 중점을 둔다
- 시스템의 일부, 모형을 만드는 과정에 사용된 코드는 추후 실제 구현의 골격이 된다고 함
- sw 개발 완료 시점에서 오류가 발생하면 폭포수 모델의 경우 그것을 되돌리기 매우 어려운데 이러한 단점을 보완하기 위함


**과정**
```
요구수집 -> 빠르게 설계 -> 프로토타입 구축 -> 고객 평가 -> 프로토타입 조정 -> 구현
```


### 나선형 모델

- 점진적으로 나선형태로 증가하게 되므로 점진적 모형이라고도 함
- 위험을 관리하고, 최소화 함에 중점을 둔 모델
- 점진적으로 기획했다가 개발했다가 하므로 누락되거나 추가되는 요구사항을 대처하기 매우 쉬움
- 유지보수가 필요없음 계속 스스로 유지보수함

**과정**
```
계획 정의 -> 위험 분석 -> 공학 개발 -> 고객 평가
```

### 애자일 모형

- 민첩하고 기민한 모형
- 고객의 요구사항 변화가 최 우선 
- 좋은걸 빠르고 낭비없게 만들기 위해 고객과의 의사소통을 최우선으로 함
- 스프린트, 이터레이션이라고 불리는 짧은 주기를 반복함
- 주기마다 고객의 평가를 수반함
- 요구사항에 우선순위를 둔다
- 소규모 프로젝트, 숙달된 개발자, 급변하는 요구사항에 어울린다
- 스크럼
- xp
- 칸반
- lean
- 크리스탈
- 등등등이 있다
- 나선형 모델을 반복해서 도는것과 유사하게 보인다.

### 기출문제
1. 폭포수 모형은 요구사항의 변경이 매우 어렵다 (4)
2. 나선형 모델은 실제 개발될 소프트웨어의 시제품을 만들어 예측하는 것이 아니다 (4) 
   > 이것은 프로토타입 모형이다
3. SM은 나선형모델의 영어이름이다 (4)
4. 애자일은 고객중심이다 (4)

## Section 2. 스크럼 기법
### 스크럼의 개요
- 스스로 팀을 꾸려 모든걸 해결하는 기법을 의미
- PO, SM, DT로 구성된다

**PO**
- 이해도가 가장높고, 요구사항을 책임지며, 의사 결정을 한다
- 주로 개발의뢰자 OR 사용자가 담당한다
- 백로그를 작성, 백로그의 우선순위를 지정한다
  > 백로그란 제품개발에 필요한 요구사항들을 정리해놓은 리스트이다.  
  > 팀원들이 백로그에 스토리를 추가할 수는 있으나 우선순위는 건들 수 없다

- 제품에 대한 테스트를 반복하며, 우선순위를 계속하여 갱신한다.

**SM**
- 객관적인 시각을 갖추고 조언자의 입장에서 임한다
- 보스가 아니다
- 일일 스크럼 회의를 주관하여, 진행사항을 점검, 개발 과정 장애요소를 공론화하여 처리한다

**DT**
- 개발팀이다
  
### 스크럼 개발 프로세스

1. 백로그 생성
   - PO가 주체가 되어 수행한다
   - 제품개발에 필요한 요구사항을 모두 나열해놓는다
   - 우선순위를 선정한다
   - 계속하여 도출해낸다
   - 릴리즈 계획을 수립한다

2. 스프린트 계획 회의
   - 백로그중에 무엇을 할것인지 골라 스프린트 라는 기간을 거쳐 요구사항을 만족한다
   - 요구사항을 개발자 별로 분할한 것을 TASK 라고 하는데, 이것을 개발자 별로 할당하여 수행할 목록인 SPRINT BACKLOG를 작성한다
    > BACKLOG는 전체 프로젝트의 요구사항 목록
    > SPRINT BACKLOG는 해당 SPRINT의 TASK들을 우선순위를 매겨놓은 목록
  
3. 스프린트
   - 실제 개발작업을 진행 2~4주 정도 진행된다고 한다
   - TASK를 기준으로 개발자에게 할당한다
   - 개발자가 원하는 TASK를 직접 골라가는 것이 이상적이라고 한다
   - todo, inprogress, done의 상태를 갖는다

4. 일일 스크럼 회의
   - 매일 회의를 한다 15분정도만
   - 해당 스프린트의 진행상황을 알 수 있는 소멸차트인 Burn Down chart를 이용한다.
   - 회의는 서서한다 
   - 스크럼 마스터가 여기에서, 주체가 된다

5. 스프린트 검토 회의
   - 스프린트를 끝내고 검토하는 회의의다.
   - po나 실 사용자가 포함된 자리에서 테스트를 진행한다
   - 한주당 한시간 수행한다
   - PO는 피드백을 포함하여 다음 스프린트를 위해 백로그를 업데이트 한다

6. 스프린트 회고
   - 피드백이다


### 기출문제

1. 스크럼
2. 백로그는 PO가 직접 작성한다
3. 스크럼의 개발과정은
   - 1. 스프린트 계획 회의
   - 2. 스프린트 
   - 3. 일일회의
   - 4. 스프린트 검토회의
   - 5. 스프린트 회고  
  의 순으로 진행된다


## Section 3. XP 기법
### XP란

XP란 수시로 발생하는 고객의 요구사항에 대처하기 위한 방법이다.
- 고객의 참여, 개발과정의 반복을 극대화한다 
- 개발 생산성을 향상시키는 방법이다
  > 몇개의 요구사항이 일부 적용된 기능을 고객에게 반복적으로 보여주고 이에대한 반응을 하나씩 확인하는 행위를 거쳐 최종 제품을 생산하는 것이다.

- XP는 짧고 반복적인 개발주기를 갖는다
- 단순하게 설계한다
- 고객의 적극적 참여를 받는다
- 릴리즈 기간을 짧게 반복한다 그리하여 고객의 요구사항 반영에 대한 가시성을 높인다
- 비교적 소규모 인원 개발에 어울린다
  
**XP 5가지 핵심가치**
1. 의사소통
2. 단순성
3. 용기
4. 존중
5. 피드백

### XP 개발 프로세스
1. 사용자의 스토리
   - 고객의 요구 사항을 간단히 시나리오로 표현
   - 내용은 기능단위, 필요하면 간단한 TEST 사항을 기재

2. 릴리즈 계획 수립
   - 몇개의 스토리가 적용되어 부분적으로 기능이 완료된 제품을 공개
   - 부분 완료, 혹은 전체완료 시점에서 일정을 수립

3. 스파이크
   - 요구사항의 신뢰성을 높이고 기술문제에 대한 위험 감소를 위해 별도로 만드는 데모 프로그램
   - 해당 이슈만을 해결하기위한 프로그램이므로, 나머지는 다 안만들고 해당 이슈만 해결할 수 있는지 없는지를 중점으로 제작한다
  
4. 이터레이션
   - 하나의 릴리즈를 쪼개면 그걸 이터레이션이라고 한다
   - 1~3주 간격으로 한다
   - 이 기간중 시나리오인 스토리가 변경될 수 있으며, 추가 및 수정된 스토리는 진행중인 이터레이션에도 포함할 수 있다.

5. 승인 검사
   - 하나의 이터레이션 내에서, 계획된 릴리즈 단위의 부분완료 제품이 구현되면 수행
   - 고객이 직접 수행한다
   - 오류를 잡으면 다음 이터레이션에서 수정한다
   - 테스트 이후 요구사항이 수정되거나 우선순위가 변경될 수 있다
    > 스토리 변경 가능
   - 테스트 완료 후 다음 이터레이션을 수행

6. 소규모 릴리즈
   - 릴리즈에 속한 이터레이션을 마치면 릴리즈한다.
   - 고객 반응을 기능별로 확인할 수 있다
    > 요구사항 대처가 매우 여유롭고 유연한다

**주요 실천 법**

1. 짝꿍 프로그래밍 
    > 다른사람과 함께 짝궁을 맺어 개발한다
  
2. 테스트 주도 개발
    > 실제 코드를 작성하기 전에, 뭘 해야할지 파악  
    > 자동 테스팅 도구를 사용

3. 전체 팀 
4. 계속적인 통합
   > CI 라고 한다 BRANCH 별로 MERGE하는 것


### 기출문제
1. XP는 고객에게 릴리즈 마다 테스트를 하게된다
2. 릴리즈 규모가 커지면 유연한 대처가 힘들다
3. 라지 릴리즈 ? ;;
4. 효율성은 5대 핵심가치에 속하지 않는다.


## Section 4. 현행 시스템 파악 (C)
### 현행 시스템 파악 절차

새로 개발하려는 개발 범위를 알기 위해
legacy를 이해하는 작업이다

1. 단계
   - 시스템 구성 파악
   - 시스템 기능 파악
   - 시스템 인터페이스 파악

2. 단계
   - 아키텍쳐 파악
   - 소프트웨어 구성 파악

3. 단계
   - 하드웨어 구성 파악
   - 네트워크 구성 파악

### 시스템 구성 파악

주요 업무를 담당하는 기간업무

이를 지원하는 지원업무로 구분하여 기술한다

### 시스템 기능 파악

주요기능, 하부기능, 세부기능으로 나누어 파악한다

### 인터페이스 파악

인터페이스를 파악한다...

### 아키텍쳐 구성 파악

최상위 수준의 계층별 아키텍쳐를 파악해야 한다

### 소프트웨어 구성 파악

### 하드웨어 구성 파악

### 네트워크 구성 파악


### 기출문제

1. 아키텍쳐 구성파악은 인터페이스 구성 파악이 아닌디 ..
2. 4번은 말도안된다.

## Section 5. 개발 기술 환경 파악


## Section 6. 요구사항 정의
### 요구사항의 개념 및 특징

- 요구사항 = 어떤 문제를 해결하기 위해 제공하는 서비스에 대한 설명
- 요구사항 = 소프트웨어의 정상 운영 제약 조건

### 요구사항의 유형

1. 기능 요구사항
   - 시스템이 뭘 하는지
   - 어떤 기능을 해야하는지
   - 입력에 대한 출력은 무엇인지
   - 데이터는 어떻게 저장하고 뭘 저장하고 뭘 연산하는지
   - 반드시 뭘 해야하는지
   - 사용자가 뭘 얻는지

2. 비기능 요구사항
   - 장비
   - 성능
   - 인터페이스
   - 데이터
   - 테스트
   - 보안
   - 품질
  
### 요구사항 개발 프로세스

```
도출 -> 분석 -> 명세 -> 확인
```

### 기출문제

1. 시스템 장애는 비기능적 요구사항이다
2. 확장성은 비기능적 요구사항이다.


## Section 7. 요구 사항 분석 기법
### 요구사항 분석기법?
요구사항이 명확하지 않아서 분석하는것이다

### 분류
- 기능, 비기능으로 분류한다
- 등등...

### 개념 모델링
- 현실세계의 추상적이거나 구체적인 무언가를 개념적으로 표현한 것
- 문제의 주체인 entity(개체), 그들간의 관계와 종속성을 반영
- usecase, dataflow, state, goal, user interaction, data 등이 존재
- **UML**을 사용한다

### 협상
- 두명의 이해관계자가 요구하는 요구사항 충돌
- 요구사항 vs 자원
- 기능요구사항 vs 비기능요구사항

### 정형 분석
- 구문, 의미를 갖는 정형화된 언어로 요구사항을 수학적으로 기호로 표현하고 이를 분석하는 것이라고 한다...


### 기출문제
1. 요구사항을 제거하면 안된다.
2. 정형분석에 관한 이야기
3. 요구사항은 하나만의 개념모델로 표현하지 않는다...
   > 이해 관계자 별로 관점이 다른것을 이애한다
   
## Section 8. 요구사항 확인 기법

## Section 9. UML
### UML의 개요
- 객체지향 모델링 언어임
- 6개의 구조다이어그램, 7개의 행위 다이어그램
- 사물 <-> 사물의 관계를 표현
- 사물, 관계 다이어그램이 있음

### 사물
- 모델을 구성하는 기본 요소 관계 형성의 주체

- 사물의 종류
  - 1. 구조 사물 : 
        - 시스템의 개념적 물리적 요소
        -  CLASS, Use Case, Component, Nodes
  - 2. 행동 사물 :
        - 움직이는거 
        - 시간과 공간에 대한 뭔가의 행위
  - 3. 그룹 사물 :
        - 패키지
  - 4. 주해 사물 :
        - ???


### 관계

- 연관
  - 2개 이상의 사물이 서로 관련됨
  - 화살표가 존재하는 실선
  - 양방향관계는 화살표 생략
  - 다중도 표시

- 집합
  - 하나의 사물이 다른 사물에 포함
  - 서로 독립적임
  - 빈 마름모

- 포함
  - 꽉찬 마름모
  - 종속적임
  - 화살표가 안붙은 쪽이 부하임

- 일반화
  - 아메리카노, 에스프레소 -> 커피
  - 상속하는것

- 의존
  - 점선
  - 짧게 영향을 주는것
  - 주유기와 자동차..

- 실체화
  - 인터페이스

### 다이어그램
    - 사물과 관계를 도형으로 표현
    - 여러관점이 존재, 가시관계로 표현
    - 정적 모델링 : 구조적 다이어그램
    - 동적 모델링 : 행위 다이어그램

- 구조적 다이어그램  
  1. 클래스 다이어그램
  2. 객체 다이어그램
  3. 컴포넌트 다이어그램
  4. 배치 다이어그램
  5. 복합체 구조 다이어그램
  6. 패키지 다이어그램

- 행위 다이어그램  
  1. 유스케이스
  2. 시퀀스
  3. 커뮤니케이션
  4. 상태
  5. 활동
  6. 상호작용
  7. 타이밍


### 기출문제

1. 물리적인 자원의 위치 = 배치
2. 분석사물은 무엇?
3. 배치는 구조적 다이어그램
4. 변화다이어그램 ??
5. 구현단계에서는 컴포넌트가 제일 적절하다고 합니다 ...



  ## Section 7. 요구 사항 분석 기법
### 요구사항 분석기법?